/**
 * Hook for fetching timeline summaries from cache
 *
 * Strategy:
 * - Only READ from DB cache - no generation triggered on view
 * - Summaries are pre-generated by background sync process
 * - Only completed periods have summaries (ongoing periods like "today" won't have one)
 */
import { useState, useEffect, useRef, useMemo } from 'react'
import { getCachedSummariesBatch } from '@/services/projects'
import type { TimelineGroup } from '@/types'

interface UseTimelineSummariesOptions {
  projectName: string
  timeUnit: string
  groups: TimelineGroup[]
}

interface UseTimelineSummariesResult {
  summaries: Record<string, string>
  isLoading: boolean
}

export function useTimelineSummaries({
  projectName,
  timeUnit,
  groups,
}: UseTimelineSummariesOptions): UseTimelineSummariesResult {
  // Store summaries keyed by "timeUnit:periodStart" to keep cache across timeUnit switches
  const [summariesByKey, setSummariesByKey] = useState<Record<string, string>>({})
  const [isLoading, setIsLoading] = useState(false)

  // Track current fetch to avoid race conditions
  const fetchIdRef = useRef(0)

  // Memoize period starts to avoid unnecessary effect triggers
  const periodStarts = useMemo(
    () => groups.map((g) => g.period_start),
    [groups]
  )

  // Fetch cached summaries from DB (read-only, no generation)
  useEffect(() => {
    if (groups.length === 0) return

    const fetchId = ++fetchIdRef.current
    setIsLoading(true)

    getCachedSummariesBatch(projectName, 'timeline', timeUnit, periodStarts)
      .then((cached) => {
        // Only update if this is still the latest fetch
        if (fetchId !== fetchIdRef.current) return

        // Store with timeUnit prefix to avoid key collisions
        const keyedCache: Record<string, string> = {}
        for (const [periodStart, summary] of Object.entries(cached)) {
          keyedCache[`${timeUnit}:${periodStart}`] = summary
        }

        // Merge with existing summaries (preserve other timeUnit summaries)
        setSummariesByKey((prev) => ({ ...prev, ...keyedCache }))
      })
      .catch((err) => {
        if (fetchId !== fetchIdRef.current) return
        console.error('Failed to load cached summaries:', err)
      })
      .finally(() => {
        if (fetchId === fetchIdRef.current) {
          setIsLoading(false)
        }
      })
  }, [projectName, timeUnit, periodStarts, groups])

  // Extract summaries for current timeUnit
  const summaries = useMemo(() => {
    const result: Record<string, string> = {}
    const prefix = `${timeUnit}:`
    for (const [key, value] of Object.entries(summariesByKey)) {
      if (key.startsWith(prefix)) {
        result[key.slice(prefix.length)] = value
      }
    }
    return result
  }, [summariesByKey, timeUnit])

  return {
    summaries,
    isLoading,
  }
}
